{"version":3,"sources":["re_posh/subs.cljc"],"mappings":"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","names":["js/re-posh","js/re-posh.subs","js/re-posh.subs.execute-sub","method-table__4619__auto__","cljs.core.atom","prefer-table__4620__auto__","method-cache__4621__auto__","cached-hierarchy__4622__auto__","hierarchy__4623__auto__","cljs.core.get","fexpr__60828","cljs.core/MultiFn","cljs.core.symbol","re-posh.subs/execute-sub","p__60829","map__60830","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","query","variables","pre-q","cljs.core/deref","cljs.core.partial","posh.reagent/q","re-posh.db/store","cljs.core.into","p__60832","map__60833","pattern","id","posh.reagent/pull","p__60835","map__60836","ids","posh.reagent/pull-many","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","re-posh.subs/reg-sub","seq60838","G__60839","cljs.core/first","cljs.core/next","self__4723__auto__","query-id","args","config-fn","cljs.core/last","input-args","cljs.core/butlast","err-header","inputs-fn","G__60840","cljs.core/count","_","f","cljs.core/fn?","re_frame.loggers.console","vec__60841","cljs.core.nth","marker","vec","cljs.core._EQ_","re_frame.core.subscribe","pairs","cljs.core.partition","markers","cljs.core.map","vecs","cljs.core/every?","cljs.core/vector?","re-frame.core/subscribe","re-frame.core/reg-sub-raw","params","G__60844","G__60845","reagent.ratom/make-reaction","inputs","signals","cljs.core/seq?","re-posh.subs/reg-query-sub","sub-name","re_posh.subs.reg_sub","p__60846","vec__60847","seq__60848","cljs.core/seq","first__60849","re-posh.subs/reg-pull-sub","p__60850","vec__60851","re-posh.subs/reg-pull-many-sub","p__60854","vec__60855"],"sourcesContent":["(ns re-posh.subs\n  (:require\n   [re-frame.core :as r]\n   [re-frame.loggers :refer [console]]\n   [re-posh.db :refer [store]]\n   [reagent.ratom :refer-macros [reaction]]\n   [posh.reagent  :as p]))\n\n(defmulti execute-sub :type)\n\n(defmethod execute-sub :query\n  [{:keys [query variables]}]\n  (let [pre-q (partial p/q query @store)]\n    (apply pre-q (into [] variables))))\n\n(defmethod execute-sub :pull\n  [{:keys [pattern id]}]\n  (p/pull @store pattern id))\n\n(defmethod execute-sub :pull-many\n  [{:keys [pattern ids]}]\n  (p/pull-many @store pattern ids))\n\n(defn reg-sub\n  \"For a given `query-id` register a `config` function and input `signals`\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a function that generates config for query or pull for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A config function is always the last argument and it has this general form:\n  `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the config functions gets as a first argument.\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-config-fn)   ;; (fn [db v]  ... a-value)\n     The node's input signal defaults to datascript database, and the value within `ds` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here, the form is (fn [db v] ... signal | [signal])\n       config-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many.\n     The values from the nominated signals will be supplied as the 1st argument to the\n     config function - either a singleton or sequence, paralleling\n     the structure returned by the signal function.\n     Here, is an example signal-fn, which returns a vector of input signals.\n       (fn [query-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n     For that signal function, the config function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n     then the config function must be written to expect a single value\n     as the 1st argument:\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n  \"\n  [query-id & args]\n  (let [config-fn  (last args)\n        input-args (butlast args)\n        err-header (str \"re-posh: reg-sub for \" query-id \", \")\n        inputs-fn  (case (count input-args)\n                     ;; no `inputs` function provided - give the default\n                     0 (fn\n                         ([_] nil)\n                         ([_ _] nil))\n\n                     ;; a single `inputs` fn\n                     1 (let [f (first input-args)]\n                         (when-not (fn? f)\n                           (console :error err-header \"2nd argument expected to ba an inputs function, got: \" f))\n                         f)\n\n                     ;; one sugar pair\n                     2 (let [[marker vec] input-args]\n                         (when-not (= :<- marker)\n                           (console :error err-header \"expected :<-, got: \" marker))\n                         (fn inp-fn\n                           ([_] (r/subscribe vec))\n                           ([_ _] (r/subscribe vec))))\n\n                     ;; multiple sugar pairs\n                     (let [pairs (partition 2 input-args)\n                           markers (map first pairs)\n                           vecs (map last pairs)]\n                       (when-not (and (every? #{:<-} markers) (every? vector? vecs))\n                         (console :error err-header \"expected pairs of :<- and vectors, got:\" pairs))\n                       (fn inp-fn\n                         ([_] (map r/subscribe vecs))\n                         ([_ _] (map r/subscribe vecs)))))]\n    (r/reg-sub-raw\n     query-id\n     (fn [_ params]\n       (if (= (count input-args) 0)\n         ;; if there is no inputs-fn provided (or sugar version) don't wrap anything in reaction,\n         ;; just return posh's query or pull\n         (execute-sub (config-fn @@store params))\n         (reaction\n          (let [inputs (inputs-fn params)\n                signals (if (seq? inputs)\n                          (map deref inputs)\n                          (deref inputs))]\n            @(execute-sub (config-fn signals params)))))))))\n\n(defn reg-query-sub\n  \"Syntax sugar for writing queries. It allows writing query subscription\n   in a very simple way:\n\n  (re-posh/reg-query-sub\n   :query-id\n   '[:find ...\n     :in $ $1 $2  ;; <- all variables go here\n     :where ...])\n\n  It's possible to subscibe to this query with\n\n  (re-posh/subscribe [:query-id var-1 var-2])\n\n  so that variables `var-1` and `var-2` will be automatically sent to `:in` form\n  \"\n  [sub-name query]\n  (reg-sub\n   sub-name\n   (fn [_ [_ & params]]\n     {:type      :query\n      :query     query\n      :variables params})))\n\n(defn reg-pull-sub\n  \"Syntax sugar for writing pull queries. It allows writing pull subscription\n  in a very simple way:\n\n  (re-posh/reg-pull-sub\n   :pull-id\n   '[*]) ;;<- pull pattern\n\n  It's possible to subscribe to this pull query with\n\n  (re-posh/subscibe [:pull-id id])\n\n  Where id is an entity id\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ id]]\n     {:type    :pull\n      :pattern pattern\n      :id      id})))\n\n(defn reg-pull-many-sub\n  \"Syntax sugar for writing pull-many queries.\n  Same as reg-pull-sub but takes vector of eids under key :ids\n\n  (reg-pull-many-sub\n   :things\n   '[*])\n\n  It's possible to subscribe to this pull-many query with\n\n  (re-posh/subscribe [:things ids])\n\n  Where ids is a sequence of entity ids\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ ids]]\n     {:type    :pull-many\n      :pattern pattern\n      :ids     ids})))\n"]}